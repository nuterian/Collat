var Stream = require('stream.js'),
	Client = require('client.js'),
	Scanner = require('scanner.js');

var net = require("net");
var EventEmitter = require('events').EventEmitter;

Array.prototype.remove = function(e) {
  for (var i = 0; i < this.length; i++) {
    if (e == this[i]) { return this.splice(i, 1); }
  }
};

function Connection(socket){
	this.id = null;
	this.name = null;
	this.socket = socket;
	this.roles = {
		Owner: 0,
		User: 1
	};
	this.role = this.roles.User;
}

var ids = [];
function genId(){
	var id = Math.round(Math.random()*(9876 - 1234) + 1234);
	while(ids.indexOf(id) != -1){
		id = Math.round(Math.random()*(9876 - 1234) + 1234);
	}
	ids.push(id);
	return id;
}

Server.prototype = new EventEmitter();
function Server(){

	var stream = new Stream();
	var _this = this;

	this.connections = [];
	this.name = '';
	this.topic = '';
	this.owner = null;
	this.listening = false;
	this.created = null;

	function send(socket, type, data){
		var m = {t: type, d: data};
		console.log(m);
		socket.write(JSON.stringify(m)+"\n");
	}

	function nameExists(name){
		if(_this.owner && name == _this.owner.name && _this.connections.length > 0) return true;
		_this.connections.forEach(function(c){
			if(c.name == name) return true;
		});
		return false;
	}

	this.server = net.createServer(function (socket) {

		//console.log('New Client');

		var conn = new Connection(socket);
		conn.id = genId();
		conn.name = 'Guest'+conn.id;
		if(_this.connections.length == 0) conn.role = conn.roles.Owner;

		socket.setTimeout(0);
		socket.setEncoding("utf8");

		_this.emit('connect');

		socket.on('data', function(data){
			var commands = stream.retrieve(data);

			commands.forEach(function(cmd){
				if(cmd.t == 'j'){

					console.log('Joining');

					if(!nameExists(cmd.d)){
						conn.name = cmd.d;
					}
					var user_list = {};
					_this.connections.forEach(function(c){
						user_list[c.id] = {
							n: c.name,
							r: c.role							
						};

					});

					send(socket, "cll", JSON.stringify(user_list));
					send(socket, "i", conn.id+" "+conn.name+" "+conn.role);

					_this.connections.push(conn);
					_this.emit('connected');

					//console.log(_this.connections);
					_this.connections.forEach(function(c){
						if(c != conn){
							send(c.socket, 'clj', conn.id+" "+conn.name+" "+conn.role);
						}
					});
				}
				else if(cmd.t == 'n'){
					if(!nameExists(cmd.d)){
						conn.name = cmd.d;
					}

					_this.connections.forEach(function(c){
						send(c.socket, 'n', conn.id+" "+conn.name);
					});
					//_this.emit('conn', conn, {type:'nick', data: cmd.d});
				}
				else if(cmd.t == 'm'){
					_this.connections.forEach(function(c){
						if(c != conn)
							send(c.socket, 'm', {id: conn.id, m: cmd.d, t:Date()});
					});					
				}
			});
		});

		socket.on('error', function(e){
		});

		socket.on('close', function(e){	
			_this.connections.forEach(function(c){
				if(c!=conn){
					send(c.socket, 'clq', conn.id);
				}
				_this.connections.remove(conn);
			});			
		});
	});

	function start(_name, _ownerName, _topic, port){
		_this.name = _name;
		_this.topic = _topic;
		_this.owner = new Client();
		_this.owner.role = _this.owner.roles.Owner;
		_this.owner.name = _ownerName;

		_this.server.listen( (port || 0) , null, null, function(){
			_this.owner.connect('localhost', _this.server.address().port);
			_this.owner.on('connected', function(){
				Scanner.broadcast(_this);	
				_this.listening = true;
			});
		});

		this.created = new Date();

		return _this.owner;
	} 

	function stop(){
		this.server.close();
		this.server.on("close", function() {console.log("closed");});
		this.connections.forEach(function(c){
			c.socket.end();
			c.socket.removeAllListeners();
			c.socket.destroy();
		});
		this.connections = [];
		this.created = null;
	}

	function setOwner(c){
		_this.owner = c;
	}

	this.setOwner = setOwner;
	this.start = start;
	this.stop = stop;
}


module.exports = new Server();