var dgram = require('dgram'),
	ifaces = require('os').networkInterfaces(),
	EventEmitter = require('events').EventEmitter;

var addresses = [];
function getAddresses(){
	Object.keys(ifaces).forEach(function(type){
	  ifaces[type].forEach(function(iface){
	    if (iface.family.toLowerCase() == 'ipv4' && iface.address != '127.0.0.1') {
	      addresses.push(iface.address);
	    }
	  });
	});	
}

Scanner.prototype = new EventEmitter;
function Scanner(){
	this.id = process.pid;
	this.groups = {};
	this.isBroadcasting = false;

	var _this = this;
	var port = 23422;
	var interval = 2000;
	var receiver;
	var sender;
	var broadcastTimer;

	getAddresses();

	function broadcaster(server){
		var data = {
			name: server.name,
			topic: server.topic, 
			users: server.connections.length,
			port: server.server.address().port,
			id: _this.id,
			created: (server.created || new Date())
		};

		var dataBuffer = new Buffer(JSON.stringify(data));
		//addresses.forEach(function(addr){
			sender.send(dataBuffer, 0, dataBuffer.length, port, '255.255.255.255', function(err, bytes){});				
		//});
	}

	function broadcast(server){
		sender = dgram.createSocket('udp4');
		sender.bind(port, '0.0.0.0', function(){
			sender.setBroadcast(true);
		});
		broadcastTimer = setInterval( function(){ broadcaster(server) } , interval);
		this.isBroadcasting = true;
	}

	function scan(){
		receiver = dgram.createSocket('udp4');
		receiver.on("message", function(data, rinfo){
			//console.log("Received: "+data+ " from: "+ rinfo.address);
			var _data = JSON.parse(data);
			if(!_this.groups[_data.id]){
				_this.groups[_data.id] = _data;
				_this.groups[_data.id]["address"] = rinfo.address;
				_this.emit("new_group", _this.groups[_data.id]);
			}
		});

		receiver.bind(port, '0.0.0.0', function(){
			receiver.setBroadcast(true);
		});
	}
/*
	function getGroup(id){
		if(groups[id]){
			return groups[id];
		}
		return false;
	}
*/

	function stopScan(){
		if(receiver._handle){
			receiver.close();
			delete receiver;
			_this.removeAllListeners();			
		}

	}

	function stopBroadcast(){
		if(sender._handle){
			sender.close();
			delete sender;
		}
		clearInterval(broadcastTimer);
		this.isBroadcasting = false;
	}
/*
	function numGroups(){
		return Object.keys(_this.groups).length || 0;
	}
*/

	this.broadcast = broadcast;
	this.stopBroadcast = stopBroadcast;
	this.scan = scan;
	this.stopScan = stopScan;
	//this.getGroup = getGroup;
	//this.numGroups = numGroups;
}

module.exports = new Scanner();